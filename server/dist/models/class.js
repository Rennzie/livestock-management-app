"use strict";function _toConsumableArray(a){return _arrayWithoutHoles(a)||_iterableToArray(a)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function _iterableToArray(a){if(Symbol.iterator in Object(a)||"[object Arguments]"===Object.prototype.toString.call(a))return Array.from(a)}function _arrayWithoutHoles(a){if(Array.isArray(a)){for(var b=0,c=Array(a.length);b<a.length;b++)c[b]=a[b];return c}}var mongoose=require("mongoose"),moment=require("moment"),ChangeTrackerSchema=new mongoose.Schema({// this will be a moment date.
createdAt:Date,reasonForChange:{type:String,enum:["add","purchase","death","theft","sale","other"]},animalsMoved:Number,notes:String}),ClassSchema=new mongoose.Schema({name:String,class:{type:String,enum:["archive","cows","bull-calves","oxen","weaners","bulls","pasturelot","feedlot","grassland","heifers-1-2","heifers-2-3","replacement-heifers"]},currentMonthDetail:{openingTotal:{type:Number,default:0},closingTotal:Number,period:{type:String,default:moment().format("MMM-YYYY")},changes:{type:Object,default:{}}},monthlyDetailArchive:{type:Object,default:{}},currentMonthChanges:[ChangeTrackerSchema],changesArchive:{type:Object,default:{}},changes:[ChangeTrackerSchema]});ClassSchema.set("toObject",{virtuals:!0}),ClassSchema.set("toJSON",{virtuals:!0}),ClassSchema.pre("save",function(a){// at first save of a new month, archive last month, set the period and the openingTotal
var b=moment().format("MMM-YYYY"),c=null;if(this.currentMonthDetail.period!==b){// archives the current month at first save of a new month
var d=JSON.parse(JSON.stringify(this.currentMonthDetail));this.monthlyDetailArchive[d.period]=d,c=startNewMonth(d.closingTotal,b)}else c=this.currentMonthDetail;// updates the closing total and the change summary object
c.closingTotal=getClosingTotal(this.currentMonthChanges,c.openingTotal),c.changes=aggregateMonthChanges(this.currentMonthChanges),this.currentMonthDetail=c,a()}),ClassSchema.methods.newChange=function(a){// on adding a new change, check it is for the current month,
//  --> if it is then add it to current month array
//  --> if its not then archive the current month array into an object with a key of MMM-YYYY
var b=moment().subtract(1,"month").format("MMM-YYYY");// if the new changes is in a the next month then start archiving things
return moment(a.createdAt).format("MMM-YYYY")===this.currentMonthDetail.period?(this.currentMonthChanges.push(a),this.save()):(this.changesArchive[b]=_toConsumableArray(this.currentMonthChanges),this.currentMonthChanges=[],this.currentMonthChanges.push(a),this.save())},module.exports=mongoose.model("Class",ClassSchema);//  === INTERNAL FUNCTION ===//
function startNewMonth(a,b){return{period:b,openingTotal:a}}// creates the summary object for the months changes
function aggregateMonthChanges(a){var b={};// accumulate the different changes for the month
return a.forEach(function(a){b[a.reasonForChange]?b[a.reasonForChange]+=a.animalsMoved:b[a.reasonForChange]=a.animalsMoved}),b}// calculates the closing total
function getClosingTotal(a,b){for(var c=b,d=0;d<a.length;d+=1)c+=a[d].animalsMoved;return c}